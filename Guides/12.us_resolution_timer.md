# 12.us Resolution Timer (get_tick_us & delay_us)

## Description
This module provides a simple interface for reading the time elapsed since system reset, with a resolution of **1 microsecond**, using a hardware timer running at 1 MHz.

**What you can do with this module:**

* Get microsecond-resolution timestamps
* Measure elapsed time between events
* Delay in microseconds
* Perform precise time profiling or benchmarking

**Limitations:**

* Maximum measurable time is limited by the timer width (e.g., 32-bit = \~4295 seconds = \~71 minutes)
* Does not handle timer overflows (you can add overflow logic if needed)
* Will not work in deep sleep modes unless the timer is on a low-power clock domain (not configured in this example)
* Timer must be manually configured to 1 MHz using STM32CubeMX

---

## Installation
Simply copy `us_timer.h` and `us_timer.c` to your `Core/Inc` and `Core/Src` folders respectively.

---

## Configuration – STM32CubeMX
Use **STM32CubeMX** to configure the hardware timer as follows:

1. **Enable a timer (e.g., TIM2):**
   * Search for your MCU's **Block Diagram**, usuallu found in the data sheet. There, find out which `APBx` your timer uses
   * In the **Clock Configuration** tab, search for the `To APBx Timer Clocks` and remember the value
   * In the **Pinout & Configuration** tab, enable **TIM2** by selecting **Clock Source → Internal Clock** and **Channel 1 → Output Compare No Output** 

2. **Timer Configuration:**

   * **Prescaler:** `(To APBx Timer Clocks / 1,000,000) - 1`

     * For example, if your core runs at 64 MHz → Prescaler = 63
     * This will make the timer run at **1 MHz** (1 us resolution)
   * **Counter Period:** `0xFFFFFFFF` (max 32-bit value)
   * **Counter Mode:** Up
   * **Auto-Reload Preload:** Disable
   * **Interrupts or DMA:** Leave disabled

---

## Usage
0. **Include `us_timer.h` in your `main.c`**

    ```c
    // main.c

    /* USER CODE BEGIN Includes */
    #include "us_timer.h"
    /* USER CODE END Includes */
    ```

1. **Start the timer once at boot time:**

   ```c
   // main.c

   /* USER CODE BEGIN 2 */
   HAL_TIM_Base_Start(&htim2);
   /* USER CODE END 2 */
   ```

2. **Get current timestamp in microseconds:**

   ```c
   uint32_t current_time_us = get_tick_us(&htim2);
   ```

3. **Measure elapsed time and delay in us:**
```c
uint32_t start = get_tick_us(&htim2);
delay_us(&htim2, 42);
uint32_t end = get_tick_us(&htim2);
uint32_t elapsed_us = end - start;
// 99.6% of the time elapsed_us will be 42. The rest of the time, it will be 42 +- 1. This is a limitation of the MCU.
```
---

## Usage Test (VALIDATED ON STM32H7A3 NUCLEO)
Below is the code that was used to validate the guide and determine the variation of the delay.

```c
#include "main.h"
#include "us_timer.h"
#include <string.h>

int main(void)
{
    /* USER CODE BEGIN WHILE */
    HAL_Delay(1);
	union delays {
		struct {
			uint32_t d41;
			uint32_t d42;
			uint32_t d43;
			uint32_t d44;
			uint32_t d45;
		};
		uint32_t buffer[5];
	};
	union delays d;
	memset(d.buffer, 0, sizeof(union delays));
	uint32_t time_begin, elapsed;
	for (int i = 0; i < 100000; i++) {
		time_begin = get_tick_us(&htim2);
		delay_us(&htim2, 42);
		elapsed = get_tick_us(&htim2) - time_begin;
		switch (elapsed) {
		case 41:
			d.d41++;
			break;
		case 42:
			d.d42++;
			break;
		case 43:
			d.d43++;
			break;
		case 44:
			d.d44++;
			break;
		case 45:
			d.d45++;
			break;
		default:
			break;
		}
	}
	float percent41 = ((float)d.d41 / 100000.0f) * 100.0f;
	float percent42 = ((float)d.d42 / 100000.0f) * 100.0f;
	float percent43 = ((float)d.d43 / 100000.0f) * 100.0f;
	float percent44 = ((float)d.d44 / 100000.0f) * 100.0f;
}
```
