# 15.Button Input System

## Description
The **Button Input System** is a lightweight, interrupt-friendly module for handling physical button input on STM32 and similar microcontrollers. It abstracts away common problems such as **debouncing**, **event queuing**, and **tracking button hold duration**. 

This system provides:
- An event queue (ring buffer) to store button press and release events without losing user input.
- Automatic software debouncing to filter out spurious signals from mechanical switches.
- A per-button hold counter that increments while the button remains pressed, enabling features such as “long press” detection or input acceleration.

## Installation
Copy the following files into your project:
   - `Core/Src/button_input.c`
   - `Core/Inc/button_input.h`

## Configuration
- **MAX_BUTTONS**: Maximum number of buttons the system will handle.
- **EVENT_BUFFER_SIZE**: Size of the event queue. Increase this if your application might accumulate many events before processing.
- **DEBOUNCE_MS**: Debounce period in milliseconds. Typical values are 10–30 ms depending on hardware.

These values can be changed in `button_input.h`.

## Usage
0. **Function prototypes**
```c
// main.c

/* USER CODE BEGIN PFP */
bool read_button0(void);
bool read_button1(void);
/* USER CODE END PFP */
```
1. **Initialization**
```c
// main.c

/* USER CODE BEGIN 2 */
button_init();
button_register(0, read_button0);
button_register(1, read_button1);
/* USER CODE END 2 */
```
Each `read_buttonX` function must be written by you in your `main.c`. It should read the corresponding GPIO pin using HAL functions and return `true` if the button is currently pressed. For example:
```c
// main.c

/* USER CODE BEGIN 4 */
bool read_button0(void) {
    return HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0) == GPIO_PIN_SET;
}

bool read_button1(void) {
    return HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_1) == GPIO_PIN_SET;
}
/* USER CODE END 4 */
```

2. **Periodic update**  
Call `button_update(now_ms)` every 1 ms. In practice, this should be placed in a **task scheduled at 1 ms period** . If you don't have a task scheduler, skip this step and call `button_update(HAL_GetTick())` in your main loop. You'll see an example in the next step.
Example:
```c
// task_scheduler.c

#define TASK1_PERIOD_MS 1
#define TASK1_ENABLED 1
static void task1() {
  button_update(HAL_GetTick());
}
```
This function applies debouncing and updates hold counters.

3. **Event handling**  
Retrieve events from the queue inside your main loop **or in another scheduled task**. If using a scheduled task, running it every **5–10 ms** is generally sufficient, since human button presses do not change faster than this. Example:
```c
// In main loop
while (1) {
  button_update(HAL_GetTick());
  ButtonEvent ev;
  while (button_pop_event(&ev)) {
      switch (ev.button_id) {
          case 0:
              if (ev.action == BUTTON_PRESS) {
                  // Handle button 0 press
              } else {
                  // Handle button 0 release
              }
              break;
          case 1:
              if (ev.action == BUTTON_PRESS) {
                  // Handle button 1 press
              } else {
                  // Handle button 1 release
              }
              break;
          // Add additional cases for other buttons as needed
      }
  }
}

// Or in a task scheduled every 5–10 ms
#define TASK2_PERIOD_MS 10
#define TASK2_ENABLED 1
static void task2() {
  ButtonEvent ev;
  while (button_pop_event(&ev)) {
      switch (ev.button_id) {
          case 0:
              if (ev.action == BUTTON_PRESS) {
                  // Handle button 0 press
              } else {
                  // Handle button 0 release
              }
              break;
          case 1:
              if (ev.action == BUTTON_PRESS) {
                  // Handle button 1 press
              } else {
                  // Handle button 1 release
              }
              break;
          // Add additional cases for other buttons as needed
      }
  }
}
```

4. **Hold counter**  
Query how long a button has been held:
```c
uint32_t held_ms = button_get_hold(0);
if (held_ms > 1000) {
    // Button 0 held for at least 1 second
}
```

This allows developers to easily implement long-press detection, input acceleration, or repeated actions.
