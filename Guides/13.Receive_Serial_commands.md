# 13.Receive serial commands

## Description
This module documents how to setup serial communication on your STM32 board so you can receive commands in the `<command_id;command_argument>` format.

## Installation
Simply copy `Core/Inc/command_parser.h` and `Core/Src/command_parser.c` to your project's `Core/Inc` and `Core/Src` folders respectively.

## Configuring
In order for the `command_parser` library to work, you need to configure a USART peripheral in CubeMX. If you have a VCP (Virtual COM Port) connected to a peripheral, use that. If not, any will do.

### In CubeMX:
USARTx:
    - Mode: Asynchronous
    - Configuration tab:
        - **Parameter Settings**: Leave everything default. Change **Baud Rate**, **Parity** and **Stop Bits** if you want.
        - **NVIC Settings**: Enable USARTx global interrupt.

### In code:
Put all these snippets in `main.c` unless instructed otherwise. Replace `huart1` with your uart handle.

0. Include command_parser.h:
```c
/* USER CODE BEGIN Includes */
#include "command_parser.h"
/* USER CODE END Includes */
```
1. Change the command buffer size (optional):
```c
// Find this in command_parser.h. You do not need to add it, it's already there
#define COMMAND_BUFFER_SIZE 8 // Make this larger if needed
```

2. Start reception:
```c
/* USER CODE BEGIN 2 */
HAL_UART_Receive_IT(&huart3, command_buff, 1);
/* USER CODE END 2 */
```

3. Define a reception completed callback:
```c
/* USER CODE BEGIN 4 */
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) {
	static uint8_t next_character_idx;
	uint8_t current_character_idx = next_character_idx++;
	if (next_character_idx >= COMMAND_BUFFER_SIZE) {
		next_character_idx = 0;
	}

	if (command_buff[current_character_idx] == '>') {
		command_ready_to_be_processed = true;
	} else {
		command_ready_to_be_processed = false;
	}

	// At this point the USART peripheral won't receive any more bytes, so we
	// need to call this function again.
	HAL_UART_Receive_IT(&huart3, &command_buff[next_character_idx], 1);
}
/* USER CODE END 4 */
```

## Usage
Assuming you have some task that runs periodically that processes commands, it might look like this:
```c
// background_tasks.c
#include "command_parser.h"

void process_command() {
  int command_id, command_arg;

  if (!command_ready_to_be_processed) {
    return; // Early return because there's no command to process yet
  }

  int status = ParseCommand(command_buff, &command_id, &command_arg);
  if (status != 2) {
    return; // Early return because parsing failed
  }

  // Parsing succeeded, now you can do whatever you need to do with the command.
}
```