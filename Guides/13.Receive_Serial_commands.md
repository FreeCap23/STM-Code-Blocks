# 13.Receive serial commands

## Description
This module documents how to setup serial communication on your STM32 board so you can receive commands in the `<command_id:command_argument>` format.

## Installation
Simply copy `Core/Inc/receive_serial_commands.h` and `Core/Src/receive_serial_commands.c` to your project's `Core/Inc` and `Core/Src` folders respectively.

## Configuring
In order for the `receive_serial_commands` library to work, you need to configure a USART peripheral in CubeMX. If you have a VCP (Virtual COM Port) connected to a peripheral, use that. If not, any will do.

### In CubeMX:
USARTx:
    - Mode: Asynchronous
    - Configuration tab:
        - **Parameter Settings**: Leave everything default. Change **Baud Rate**, **Parity** and **Stop Bits** if you want.
        - **NVIC Settings**: Enable USARTx global interrupt.

### In code:
Put all these snippets in `main.c` unless instructed otherwise. Replace `huart1` with your uart handle.

0. Include receive_serial_commands.h:
```c
/* USER CODE BEGIN Includes */
#include "receive_serial_commands.h"
/* USER CODE END Includes */
```

1. Change the command buffer size (optional):
```c
// Find this in receive_serial_commands.h. You do not need to add it, it's already there
#define COMMAND_BUFFER_SIZE 8 // Make this larger if needed
```

2. Start reception:
```c
/* USER CODE BEGIN 2 */
HAL_UART_Receive_IT(&huart3, command_buff, 1);
/* USER CODE END 2 */
```

## Usage
Assuming you have some task that runs periodically that processes commands, it might look like this:
```c
// background_tasks.c
#include "receive_serial_commands.h"

void process_command() {
  int command_id, command_arg;

  if (!command_ready_to_be_processed) {
    return; // Early return because there's no command to process yet
  }

  int status = ParseCommand(command_buff, &command_id, &command_arg);
  if (status != 2) {
    return; // Early return because parsing failed
  }

  // Parsing succeeded, now you can do whatever you need to do with the command.
  // For example, we'll use an enum and a switch case to decide what to do
	enum {
		CONNECTION_OK = 0,
		VBATT_BUTTON,
		VBOOST_BUTTON,
		TOGGLE_LED = 999
	};

	switch (command_id) {
	case CONNECTION_OK:
		// Do something
		break;
	case VBATT_BUTTON:
		// Do something
		break;
	case VBOOST_BUTTON:
		// Do something
		break;
	case TOGGLE_LED:
		// Do something
		break;
	default: // Code in this casea will be executed if command_id doesn't match any other cases
		break;
	}
}
```